#![no_std]
#![no_main]

#![allow(non_upper_case_globals)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(dead_code)]

use aya_ebpf::{
    helpers::bpf_probe_read_kernel_str_bytes, macros::{map, tracepoint}, maps::PerCpuArray, programs::TracePointContext
};
use aya_log_ebpf::info;
use binding::filename;
mod binding;

#[repr(C)]
struct Buffer {
    pub data: [u8; 256],
}

#[map]
static mut BUFFER: PerCpuArray<Buffer> = PerCpuArray::with_max_entries(1, 0);

#[tracepoint]
pub fn trace_point_execve(ctx: TracePointContext) -> u32 {
    match try_trace_point_execve(ctx) {
        Ok(ret) => ret,
        Err(_) => 1,
    }
}

fn try_trace_point_execve(ctx: TracePointContext) -> Result<u32, i64> {
    // let buffer = unsafe {
    //     let ptr = BUFFER.get_ptr_mut(0).ok_or(1i64)?;
    //     &mut *ptr
    // };
    let mut buf = [0u8; 50];
    let file_name: filename = unsafe {ctx.read_at::<filename>(16).map_err(|e|e)? };
    // let file_path_ptr = unsafe {ctx.as_ptr().add(16) as *const c_uchar };
    let file_name_str = unsafe {
        // core::str::from_utf8_unchecked(bpf_probe_read_kernel_str_bytes(file_name.name as *const u8, &mut buffer.data)?)
        core::str::from_utf8_unchecked(bpf_probe_read_kernel_str_bytes(file_name.name as *const u8, &mut buf).map_or(&[42], |x| x))
    };
    info!(&ctx, "tracepoint sys_enter_execve called : {}", file_name_str);
    // info!(&ctx, "tracepoint sys_enter_execve called");
    Ok(0)
}

#[panic_handler]
fn panic(_info: &core::panic::PanicInfo) -> ! {
    unsafe { core::hint::unreachable_unchecked() }
}
