#![no_std]
#![no_main]

#![allow(non_upper_case_globals)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(dead_code)]

use core::ffi::c_char;

use aya_ebpf::{
    helpers::{bpf_get_current_pid_tgid, bpf_get_current_uid_gid, bpf_probe_read_kernel, bpf_probe_read_user_str_bytes}, macros::{map, tracepoint}, maps::{PerCpuArray, PerfEventArray}, programs::TracePointContext
};
use aya_log_ebpf::info;
// use aya_log_ebpf::info;
use trace_point_execve_common::Event;
mod binding;

// #[repr(C)]
// struct Buffer {
//     pub data: [u8; 1024],
// }

#[repr(C)]
pub struct SysEnterExecve {
    common_type: u16,
    common_flags: u8,
    common_preempt_count: u8,
    common_pid: i32,
    __syscall_nr: i32,
    filename: *const u8,  // `const char *`은 러스트에서 포인터로 처리
    argv: *const *const u8,  // `const char *const *` 역시 포인터의 포인터로 처리
    envp: *const *const u8,
}


#[map]
static mut BUFFER: PerCpuArray<Event> = PerCpuArray::with_max_entries(1, 0);

#[map]
static mut EVENTS : PerfEventArray<Event> = PerfEventArray::new(0);

#[tracepoint]
pub fn trace_point_execveat(ctx: TracePointContext) -> u32 {
    match try_trace_point_execve_common(ctx, 24) {
        Ok(ret) => ret,
        Err(_) => 1,
    }
}

#[tracepoint]
pub fn trace_point_execve(ctx: TracePointContext) -> u32 {
    match try_trace_point_execve_common(ctx, 16) {
        Ok(ret) => ret,
        Err(_) => 1,
    }
}

fn try_trace_point_execve_common(ctx: TracePointContext, filename_offset: usize) -> Result<u32, i64> {
    let buffer = unsafe {
        let ptr = BUFFER.get_ptr_mut(0).ok_or(1i64)?;
        &mut *ptr
    };
    // let mut buf = [0u8; 50];
    unsafe {
        let filename_ptr = ctx.read_at::<*const c_char>(filename_offset).map_err(|e|e)? as *const u8;

        if !filename_ptr.is_null() {
            buffer.filename.fill(0);
            // let args = bpf_probe_read_kernel(args_ptr).map_err(|e| e)?;
            bpf_probe_read_user_str_bytes(filename_ptr, &mut buffer.filename)?;
            // info!(&ctx, "tracepoint sys_enter_execve called : {}", file_name_len);
            // info!(&ctx, "tracepoint sys_enter_execve called : {}", file_name_str);
            // bpf_printk!(b"tracepoint sys_enter_execve called : %s", args.filename);
            buffer.uid = bpf_get_current_uid_gid() as u32;
            buffer.pid = (bpf_get_current_pid_tgid() >> 32) as u32;
            EVENTS.output(&ctx, buffer, 0)
        }
    }
    // info!(&ctx, "tracepoint sys_enter_execve called");
    Ok(0)
}

#[panic_handler]
fn panic(_info: &core::panic::PanicInfo) -> ! {
    unsafe { core::hint::unreachable_unchecked() }
}
